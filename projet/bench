using Statistics
using Printf

include(joinpath(@__DIR__, "phase2", "main.jl"))

# List of stsp instances
const STSP_DIR = joinpath(@__DIR__, "..", "instances", "stsp")
const STSP = readdir(STSP_DIR)

"""
    read_graph_stsp(filename)

Construct a graph from given stsp file.
"""
function read_graph_stsp(filename::String)
    header = read_header(filename)
    nom = header["NAME"]
    graph_edges = read_edges(header,filename)
    G = Graph(nom, Node{Vector{Float64}}[], Edge{Vector{Float64}}[])

    # On ajoute les noueds un par un au graphe G
    if header["DISPLAY_DATA_TYPE"]=="None"
        graph_nodes = Dict(i => [NaN,NaN] for i = 1 : parse(Int,header["DIMENSION"]))
        for (i,nodes) in graph_nodes
        add_node!(G, Node(string(i), nodes))
        end
    else
        graph_nodes = read_nodes(header,filename)
        for (i,nodes) in graph_nodes
            add_node!(G, Node(string(i), nodes))
        end
    end
    # On ajoute les arêtes au graphe G
    for e in graph_edges
        add_edge!(G, Edge((Node(string(e[1]), graph_nodes[e[1]]), Node(string(e[2]), graph_nodes[e[2]])), e[3]))
    end
    return G
end

const GRAPHS = [read_graph_stsp(joinpath(STSP_DIR, finst)) for finst in STSP]

"""
    run_kruskal(graphs)

Run Kruskal's algorithm on each graph `g ∈ graphs`.
"""
function run_kruskal(graphs)
    for g in graphs
        mst = kruskal(g)
    end
    return nothing
end

# First round for compilation
run_kruskal(GRAPHS)

# Second round
# Here we record times
N = 16  # Number of runs. Higher yields more accurate results
T = Float64[]
for i in 1:N
    t = @elapsed run_kruskal(GRAPHS)
    push!(T, t)
end

μ = mean(T)  # mean
σ = std(T)   # standard deviation

# Print results
@printf "Total time: %8.4f\n" sum(T)
@printf "Min   time: %8.4f\n" minimum(T)
@printf "CI-lo time: %8.4f\n" μ - (2.0 / sqrt(N)) * σ
@printf "Mean  time: %8.4f\n" μ
@printf "CI-up time: %8.4f\n" μ + (2.0 / sqrt(N)) * σ
@printf "Max   time: %8.4f\n" maximum(T)
